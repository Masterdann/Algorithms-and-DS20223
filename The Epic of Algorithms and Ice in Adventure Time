#include <iostream>
#include <vector>

using namespace std;

class SegmentTree {
 private:
  struct Node {
    int maxLeft;
    int maxRight;
    int updateSum;
  };

  vector<Node> tree;
  vector<int> arr;
  int n;

  void BuildTree(int node, int start, int end) {
    if (start == end) {
      tree[node].maxLeft = arr[start];
      tree[node].maxRight = arr[start];
      tree[node].updateSum = 0;
    } else {
      int mid = (start + end) / 2;
      BuildTree(2 * node, start, mid);
      BuildTree(2 * node + 1, mid + 1, end);

      tree[node].maxLeft =
          max(tree[2 * node].maxLeft, tree[2 * node].maxRight) +
          tree[2 * node].updateSum;
      tree[node].maxRight =
          max(tree[2 * node + 1].maxRight, tree[2 * node + 1].maxLeft) +
          tree[2 * node + 1].updateSum;
      tree[node].updateSum = 0;
    }
  }

  void UpdateRange(int node, int start, int end, int l, int r, int x) {
    if (start > end or start > r or end < l) return;

    if (start >= l && end <= r) {
      tree[node].updateSum += x;
      return;
    }

    int mid = (start + end) / 2;
    UpdateRange(2 * node, start, mid, l, r, x);
    UpdateRange(2 * node + 1, mid + 1, end, l, r, x);
    tree[node].maxLeft = max(tree[2 * node].maxLeft, tree[2 * node].maxRight) +
                         tree[2 * node].updateSum;
    tree[node].maxRight =
        max(tree[2 * node + 1].maxRight, tree[2 * node + 1].maxLeft) +
        tree[2 * node + 1].updateSum;
  }

  int QueryRange(int node, int start, int end, int l, int r) {
    if (start > end or start > r or end < l) return 0;

    if (start >= l && end <= r)
      return max(tree[node].maxLeft, tree[node].maxRight) +
             tree[node].updateSum;

    int mid = (start + end) / 2;
    int leftChild = QueryRange(2 * node, start, mid, l, r);
    int rightChild = QueryRange(2 * node + 1, mid + 1, end, l, r);

    return max(leftChild, rightChild) + tree[node].updateSum;
  }

 public:
  SegmentTree(const vector<int>& input) {
    n = input.size();
    arr = input;
    tree.resize(4 * n);

    BuildTree(1, 0, n - 1);
  }

  void Update(int l, int r, int x) { UpdateRange(1, 0, n - 1, l, r, x); }

  int Query(int l, int r) { return QueryRange(1, 0, n - 1, l, r); }
};

int main() {
  int n;
  std::cin >> n;
  vector<int> v(n);
  for (int i = 0; i < n; i++) {
    std::cin >> v[i];
  }
  SegmentTree segmentTree(v);
  int capacity, q;
  std::cin >> capacity >> q;
  std::vector<int> answer;
  for (int i = 0; i < q; i++) {
    int l, r, x;
    std::cin >> l >> r >> x;
    int maxi = segmentTree.Query(l, r);
    if (maxi + x > capacity) {
      answer.push_back(i);
      continue;
    }
    segmentTree.Update(l, r, x);
  }
  for (int i = 0; i < answer.size(); i++) {
    std::cout << answer[i] << " ";
  }
  std::cout << endl;
  return 0;
}
